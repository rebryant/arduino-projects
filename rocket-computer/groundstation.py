#!/usr/bin/python3
# Read data generated by flight computer from serial port

# Each sample contains:
# Sequence Id
# X, Y, Z accelarations in m/s^2
# Nominal altitude in m
# 4-byte checksum

import serial
import sys
import glob
import select
import getopt
import time
import datetime
import math


def usage(name):
    print("Usage: %s [-h] [-v VERB] [-p PORT] [-b BAUD] [-t TRIES] [-s SENDER]" % name)
    
def trim(s):
    while len(s) > 0 and s[-1] in "\r\n":
        s = s[:-1]
    return s

devPrefix = "/dev/cu.usbmodem"
readTimeout = 15

gravity = 9.80665
baseAltitude = 0.0

def findPorts():
    return glob.glob(devPrefix + "*")

def readline(ser):
    failures = 0
    line = None
    while line is None and failures < 10:
        try:
            line = trim(ser.readline().decode())
        except:
            failures += 1
    return line
    
class Sampler:
    port = None
    baud = None
    senderId = None
    retries = 10
    verbosity = 1

    reader = None
    # Samples indexed by sequence number
    # Each is a triple:
    #   Time (floating point #secconds since start)
    #   RSSI
    #   Sample payload.  Kept as string
    sampleBuffer = {}
    lastSampleId = -1
    rpt = 1
    startTime = 0.0

    receptionRate = 1.0
    receptionCount = 0
    done = False
    
    
    def __init__(self, port, baud, senderId, verbosity, retries):
        self.port = port
        self.baud = baud
        self.verbosity = verbosity
        self.retries = retries
        self.senderId = senderId
        self.reader = None
        self.sampleBuffer = {}
        self.lastSampleId = -1
        self.done = False
        self.receptionRate = 1.0
        self.receptionCount = 0
        self.startTime = datetime.datetime.now()
    
    def report(self, level, msg):
        if self.verbosity >= level:
            print(msg)

    def timeStamp(self):
        dt = datetime.datetime.now() - self.startTime
        secs = dt.seconds + 1e-6 * dt.microseconds
        return secs

    def error(self, fatal,  msg):
        if fatal and self.verbosity >= 1:
            print("ERROR: " + msg)
        elif self.verbosity >= 2:
            print("WARNING: " + msg)
        if fatal:
            self.done = True
        

    def connect(self):
        failures = 0
        self.reader = None
        while not self.done and self.reader is None and failures <= self.retries:
            try:
                self.reader = serial.Serial(self.port, self.baud, timeout = readTimeout)
                self.report(3, "Created serial reader port=%s, baud=%d, timeout=%d" % (self.port, self.baud, readTimeout))
            except:
                self.reader = None
                self.report(3, "Couldn't open serial port %s.  %d accumulated failures" % (self.port, failures))
                failures += 1
                time.sleep(1)
                continue
            self.report(2, "Connected to serial port %s at baud rate %d" % (self.port, self.baud)) 
            # New connection
            self.lastSampleId = -1
            self.receptionRate = 1.0
            self.sampleBuffer = {}
            return
        self.done = True
    
    def checkDone(self):
        avail =  select.select([sys.stdin], [], [], 0)
        if sys.stdin in avail[0]:
            char = sys.stdin.read(1)
            print("Read '%s' from stdin" % char)
            if len(char) > 0 and char[0] == 'q':
                self.done = True
        

    # Use decaying value
    def updateRate(self, received):
        if received:
            self.receptionRate = 0.99 * self.receptionRate + 0.01
        else:
            self.receptionRate = 0.99

    def getLine(self):
        failures = 0
        if self.reader is None:
            self.connect()
        if self.reader is None:
            return None
        while (not self.done and failures < self.retries):
            try:
                line = readline(self.reader)
            except Exception as ex:
                self.error(False, "Readline failed: %s" % str(ex))
                line = None
            self.report(4, "Read line '%s'" % trim(str(line)))
            if line is None:
                self.report(3, "Read Failed.  %d accumulated failures" % (failures))
                failures += 1
                time.sleep(1)
                self.connect()
            else:
                return trim(line)
        self.done = True
        return None

    def getNextSampleTuple(self):
#        self.checkDone()
        while len(self.sampleBuffer) == 0 and not self.done:
            line = self.getLine()
            if line is not None:
                self.parseLine(line)
        catchingUp = self.lastSampleId < 0
        if len(self.sampleBuffer) > 0:
            # Sometimes start at middle of stream
            self.lastSampleId += 1
            while self.lastSampleId not in self.sampleBuffer:
                self.lastSampleId += 1
                if not catchingUp:
                    # Missed sample
                    self.updateRate(False)
            sampleTuple = self.sampleBuffer[self.lastSampleId]
            self.updateRate(True)
            self.receptionCount += 1
            catchingUp = False
            del self.sampleBuffer[self.lastSampleId]
            return sampleTuple
        return None
                

    def parseLine(self, line):
        fields = line.split()
        if len(fields) < 3:
            self.error(False, "Line '%s'.  Not enough fields" % line)
            return
        if self.senderId is not None and fields[2] != self.senderId:
            self.error(False, "Line '%s'.  Incorrect sender Id" % line)
            return
        try:
            rpt = int(fields[1])
        except:
            self.error(False, "Line '%s'.  Couldn't parse rpt field" % line)
            return
        if rpt == 0:
            self.report("Hit end of transmission")
            return
        if rpt <= 0:
            self.error(False, "Line '%s'.  Invalid rpt field" % line)
            return
        if rpt == 0:
            self.done = True
            return
        try:
            rssi = int(fields[0])
        except:
            self.error(False, "Line '%s'.  Couldn't parse RSSI field" % line)
            return
        if (len(fields) - 3) % rpt != 0:
            self.error(False, "Line '%s'.  Can't have %d fields with rpt = %d" % (line, len(fields), rpt))
            return
        fps = (len(fields)-3)//rpt
        # See if this is start of new stream
        maxSid = None
        offset = 3
        while offset < len(fields):
            try:
                sid = int(fields[offset])
            except:
                pass
            maxSid = sid if maxSid is None else max(maxSid, sid)
            offset += 3

        # See if sequence ID has shifted lower
        if maxSid < self.lastSampleId:
            self.report(3, "Starting new stream")
            # Resetting stream
            self.lastSampleId = -1
            self.receptionRate = 1.0
            self.sampleBuffer = {}
        
        offset = 3
        while offset < len(fields):
            try:
                sid = int(fields[offset])
            except:
                pass
            if sid > self.lastSampleId and sid not in self.sampleBuffer:
                sample = " ".join(fields[offset:offset+fps])
                t = self.timeStamp()
                self.sampleBuffer[sid] = (t, sample, rssi)
            offset += fps
        
# How many sample tuples should be kept
sampleKeep = 100
# Timings of last sampleWindow receptions.  Each entry is a tuple (secs, receivedCount)
sampleHistory = []

def formatSample(sampleTuple, sampler):
    global sampleHistory
    global baseAltitude
    (secs, sample, rssi) = sampleTuple
    fields = sample.split()
    if len(fields) < 5:
        sampler.report(3, "Not enough fields in sample '%s'" % sample)
        return
    try:
        sid = int(fields[0])
    except:
        sampler.report(3, "Couldn't parse sample Id in '%s' (length=%d)" % (fields[0], len(fields[0])))
        return
    try:
        ax = float(fields[1])
    except:
        sampler.report(3, "Couldn't parse X acceleration in '%s' (length=%d)" % (fields[1], len(fields[1])))
        return
    try:
        ay = float(fields[2])
    except:
        sampler.report(3, "Couldn't parse Y acceleration in '%s' (length=%d)" % (fields[2], len(fields[2])))
        return
    try:
        az = float(fields[3])
    except:
        sampler.report(3, "Couldn't parse Z acceleration in '%s' (length=%d)" % (fields[3], len(fields[3])))
        return
    try:
        alt = float(fields[4])
    except:
        sampler.report(3, "Couldn't parse altitude in '%s' (length=%d)" % (fields[4], len(fields[4])))
        return
    if baseAltitude == 0.0:
        baseAltitude = alt
    ncount = sampler.receptionCount
    sampleHistory.append((secs, ncount))
    if len(sampleHistory) > sampleKeep:
        sampleHistory = sampleHistory[-sampleKeep:]
    osecs, ocount = sampleHistory[0]
    freq = 0.0 if ocount == ncount else float(ncount-ocount)/(secs-osecs)
    alt = alt-baseAltitude
    ax /= gravity
    ay /= gravity
    az /= gravity
    a = math.sqrt(ax*ax + ay*ay + az*az)

    rate = sampler.receptionRate * 100
    print("%d.  T = %.3f.  Alt = %.2f.  G's = %.2f (%.2f, %.2f, %.2f). SPS = %.2f.  Rcvd = %.1f%%.  RSSI = %d" % (sid, secs, alt, a, ax, ay, az, freq, rate, rssi))


    
def run(name, args):
    port = None
    baud = 115200
    retries = 10
    verbosity = 1
    senderId = None

    optList, args = getopt.getopt(args, "hv:p:b:t:s:")
    for (opt, val) in optList:
        if opt == '-h':
            usage(name)
            return
        elif opt == '-v':
            verbosity = int(val)
        elif opt == '-p':
            try:
                pnum = int(val)
                port = devPrefix + str(pnum)
            except:
                port = val
        elif opt == '-b':
            baud = int(val)
        elif opt == '-t':
            retries = int(val)
        elif opt == '-s':
            senderId = val

    if port is None:
        plist = findPorts()
        if len(plist) == 0:
            print("Can't find any devices starting with names '%s'" % devPrefix)
            return
        elif len(plist) == 1:
            port = plist[0]
        elif len(plist) == 2:
            print("Ambiguous port.  Candidates are:")
            for p in plist:
                print("  %s" % p)
            return


    sampler = Sampler(port, baud, senderId, verbosity, retries)
    while True:
        tup = sampler.getNextSampleTuple()
        if tup is None:
            print("Exiting")
            return
        formatSample(tup, sampler)
    
if __name__ == "__main__":
    run(sys.argv[0], sys.argv[1:])
    sys.exit(0)
    
