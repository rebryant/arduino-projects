#!/usr/bin/python3
# Read data generated by flight computer from serial port

# Each sample contains:
# Sequence Id
# X, Y, Z accelarations in m/s^2
# Nominal altitude in m

import serial
import sys
import glob
import select
import getopt
import time
import datetime
import math
import threading


def usage(name):
    print("Usage: %s [-h] [-B] [-S] [-L] [-v VERB] [-p PORT] [-b BAUD] [-t TRIES] [-s SENDER] [-k BSIZE]" % name)
    print(" -h       Print this message")
    print(" -B       Show only basic data")
    print(" -S       Slow to ~ 1 sample per second")
    print(" -L       Save samples to CSV log file")
    print(" -v VERB  Verbosity level")
    print(" -k BSIZE Buffer with up to BSIZE samples")

    
def trim(s):
    while len(s) > 0 and s[-1] in "\r\n":
        s = s[:-1]
    return s

devPrefix = "/dev/cu.usbmodem"
readTimeout = 15

gravity = 9.80665

# What is assumed maximum spacing between samples
maxGap = 0.2

def findPorts():
    return glob.glob(devPrefix + "*")

def readline(ser):
    failures = 0
    line = None
    while line is None and failures < 10:
        try:
            line = trim(ser.readline().decode())
        except:
            failures += 1
    return line
    
def logFileName():
    n = datetime.datetime.now()
    s = n.isoformat(sep='d', timespec='minutes')
    clist = [c for c in s]
    fclist = ["h" if c == ":" else c for c in clist]
    return "log-" + "".join(fclist) + "m.csv"

def addLog(logName, fields, first = False):
    try:
        lfile = open(logName, "w" if first else "a")
    except:
        print("Failed to add entry to log file %s" % logName)
    lfile.write(",".join(fields) + "\n")
    lfile.close()
    
    

class Sampler:
    port = None
    baud = None
    senderId = None
    retries = 10
    verbosity = 1

    reader = None
    # Samples indexed by sequence number
    # Each is a triple:
    #   Time (floating point #secconds since start)
    #   RSSI
    #   Sample payload.  Kept as string
    sampleBuffer = {}
    lastSampleId = -1
    lastSampleTime = -2.0
    rpt = 1
    startTime = 0.0

    receptionRate = 1.0
    receptionCount = 0
    done = False
    
    
    def __init__(self, port, baud, senderId, verbosity, retries):
        self.port = port
        self.baud = baud
        self.verbosity = verbosity
        self.retries = retries
        self.senderId = senderId
        self.reader = None
        self.sampleBuffer = {}
        self.lastSampleId = -1
        self.lastSampleTime = -2.0
        self.done = False
        self.receptionRate = 1.0
        self.receptionCount = 0
        self.startTime = datetime.datetime.now()
    
    def report(self, level, msg):
        if self.verbosity >= level:
            print(msg)

    def terminate(self):
        print("Can't terminate unbufferred sampler")

    def newConnection(self):
        # New connection
        self.lastSampleId = -1
        self.lastSampleTime = -2.0
        self.receptionRate = 1.0
        self.sampleBuffer = {}


    def timeStamp(self):
        dt = datetime.datetime.now() - self.startTime
        secs = dt.seconds + 1e-6 * dt.microseconds
        return secs

    def error(self, fatal,  msg):
        if fatal and self.verbosity >= 1:
            print("ERROR: " + msg)
        elif self.verbosity >= 2:
            print("WARNING: " + msg)
        if fatal:
            self.done = True
        

    def connect(self):
        failures = 0
        self.reader = None
        while not self.done and self.reader is None and failures <= self.retries:
            try:
                self.reader = serial.Serial(self.port, self.baud, timeout = readTimeout)
                self.report(3, "Created serial reader port=%s, baud=%d, timeout=%d" % (self.port, self.baud, readTimeout))
            except:
                self.reader = None
                self.report(3, "Couldn't open serial port %s.  %d accumulated failures" % (self.port, failures))
                failures += 1
                time.sleep(1)
                continue
            self.report(1, "Connected to serial port %s at baud rate %d" % (self.port, self.baud)) 
            self.newConnection()
            return
        self.done = True
    
    def checkDone(self):
        avail =  select.select([sys.stdin], [], [], 0)
        if sys.stdin in avail[0]:
            char = sys.stdin.read(1)
            print("Read '%s' from stdin" % char)
            if len(char) > 0 and char[0] == 'q':
                self.done = True
        

    # Use decaying value
    def updateRate(self, received):
        if received:
            self.receptionRate = 0.99 * self.receptionRate + 0.01
        else:
            self.receptionRate = 0.99 * self.receptionRate

    def getLine(self):
        failures = 0
        if self.reader is None:
            self.connect()
        if self.reader is None:
            return None
        while (not self.done and failures < self.retries):
            try:
                line = readline(self.reader)
            except Exception as ex:
                self.error(False, "Readline failed: %s" % str(ex))
                line = None
            self.report(4, "Read line '%s'" % trim(str(line)))
            if line is None:
                self.report(3, "Read Failed.  %d accumulated failures" % (failures))
                failures += 1
                time.sleep(1)
                self.connect()
            else:
                return trim(line)
        self.done = True
        return None

    def getNextSampleTuple(self):
#        self.checkDone()
        while len(self.sampleBuffer) == 0 and not self.done:
            line = self.getLine()
            if line is not None:
                self.parseLine(line)
        catchingUp = self.lastSampleId < 0
        if len(self.sampleBuffer) > 0:
            # Sometimes start at middle of stream
            self.lastSampleId += 1
            while self.lastSampleId not in self.sampleBuffer:
                self.lastSampleId += 1
                if not catchingUp:
                    # Missed sample
                    self.updateRate(False)
            sampleTuple = self.sampleBuffer[self.lastSampleId]
            self.updateRate(True)
            self.receptionCount += 1
            catchingUp = False
            del self.sampleBuffer[self.lastSampleId]
            return sampleTuple
        return None
                

    def parseLine(self, line):
        fields = line.split()
        if len(fields) < 3:
            self.error(False, "Line '%s'.  Not enough fields" % line)
            return
        if self.senderId is not None and fields[2] != self.senderId:
            self.error(False, "Line '%s'.  Incorrect sender Id" % line)
            return
        try:
            rpt = int(fields[1])
        except:
            self.error(False, "Line '%s'.  Couldn't parse rpt field" % line)
            return
        if rpt == 0:
            self.report(2, "Hit end of transmission")
            return
        if rpt <= 0:
            self.error(False, "Line '%s'.  Invalid rpt field" % line)
            return
        if rpt == 0:
            self.done = True
            return
        try:
            rssi = int(fields[0])
        except:
            self.error(False, "Line '%s'.  Couldn't parse RSSI field" % line)
            return
        if (len(fields) - 3) % rpt != 0:
            self.error(False, "Line '%s'.  Can't have %d fields with rpt = %d" % (line, len(fields), rpt))
            return
        fps = (len(fields)-3)//rpt
        # See what samples are included
        sidList = []
        offset = 3
        while offset < len(fields):
            try:
                sid = int(fields[offset])
                sidList.append(sid)
            except:
                pass
            offset += fps
        if len(sidList) == 0:
            return
        # See if sequence ID has shifted lower
        if  max(sidList) < self.lastSampleId:
            self.report(3, "Starting new stream")
            # Resetting stream
            self.newConnection()
        
        # Find out which Ids will be added
        sidList = sorted([sid for sid in sidList if sid > self.lastSampleId and sid not in self.sampleBuffer])
        # Determine interpolating values for times
        t = self.timeStamp()
        if (t-self.lastSampleTime) > maxGap:
            self.lastSampleTime = t - maxGap
        dt = t-self.lastSampleTime
        incrT = dt/(len(sidList)+1)
        sidTimes = {}
        self.lastSampleTime += incrT
        for sid in sidList:
            sidTimes[sid] = self.lastSampleTime
            self.lastSampleTime += incrT
        offset = 3
        while offset < len(fields):
            try:
                sid = int(fields[offset])
            except:
                pass
            if sid > self.lastSampleId and sid not in self.sampleBuffer:
                sample = " ".join(fields[offset:offset+fps])
                t = sidTimes[sid]
                self.sampleBuffer[sid] = (t, sample, rssi)
                self.report(3, "Creating sample with time %.3f, sid %d" % (t, sid))
            else:
                self.report(3, "Skipping sample with sid %d" % sid)
            offset += fps
        
# FIFO that saves only bounded number of objects.
# When hit size limit, drop oldest object(s)
# Can be configured to have separate thread filling the buffer


class DropBuffer:
    maxSize = 1
    buffer = []
    cv = None
    mutex = None
    thread = None
    filler = None
    stop = False
    
    def __init__(self, maxSize):
        self.maxSize = maxSize
        self.buffer = []
        self.cv = threading.Condition()
        self.mutex = threading.Lock()
        self.insertCount = 0
        self.retrieveCount = 0
        self.thread = None
        self.filler = None
        self.stop = False

    def insert(self, object):
        with self.cv:
            self.buffer.append(object)
            if len(self.buffer) > self.maxSize:
                self.buffer = self.buffer[-self.maxSize:]
            self.cv.notify()
        
    def retrieve(self):
        with self.cv:
            while len(self.buffer) == 0:
                self.cv.wait()
            object = self.buffer[0]
            self.buffer = self.buffer[1:]
        return object
        
    def threadRoutine(self):
        while True:
            self.mutex.acquire()
            if self.stop:
                break
            self.mutex.release()
            object = self.filler()
            self.insert(object)
        self.mutex.release()

    def keepFilled(self, filler):
        self.filler = filler
        self.thread = threading.Thread(target=self.threadRoutine)
        self.thread.start()

    def statistics(self):
        return (self.insertCount, self.retrieveCount)

    def terminate(self):
        print("Terminating buffer ...")
        self.mutex.acquire()
        self.stop = True
        self.mutex.release()
        self.thread.join()
        print("Termination complete")


class BufferedSampler(Sampler):
    buffer = None

    def __init__(self, port, baud, senderId, verbosity, retries, bufSize):
        super().__init__(port, baud, senderId, verbosity, retries)
        self.buffer = DropBuffer(bufSize)
        self.buffer.keepFilled(super().getNextSampleTuple)

    def getNextSampleTuple(self):
        return self.buffer.retrieve()

    def statistics(self):
        return self.buffer.statistics()

    def terminate(self):
        self.buffer.terminate()

class SampleRecord:
    timeStamp = 0.0
    sequenceId = 0
    altitude = 0.0
    accelerationX = 0.0
    accelerationY = 0.0
    accelerationZ = 0.0
    frequency = 0.0
    reliability = 0.0
    rssi = 0

    def __init__(self, time = None, sid = None, alt = None, ax = None, ay = None , az = None, freq = None, rate=None, rssi=None):
        self.timeStamp = time
        self.sequenceId = sid
        self.altitude = alt
        self.accelerationX = ax
        self.accelerationY = ay    
        self.accelerationZ = az
        self.frequency = freq
        self.reliability = rate
        self.rssi = rssi
    
    # Find magnitude of acceleration among some subset of X, Y, and Z axes.  Specify with substring of "xyz"
    def acceleration(self, dimensions = None):
        if dimensions is None or dimensions == "":
            dimensions = "xyz"
        sval = 0.0
        if "x" in dimensions:
            sval += self.accelerationX * self.accelerationX
        if "y" in dimensions:
            sval += self.accelerationY * self.accelerationY
        if "z" in dimensions:
            sval += self.accelerationZ * self.accelerationZ
        return math.sqrt(sval)

    def getField(self, kwd):
        kwd = kwd.lower()
        if kwd == 'sequence':
            return self.sequenceId
        elif kwd == 'altitude':
            return self.altitude
        elif kwd == 'acceleration-x':
            return self.accelerationX
        elif kwd == 'acceleration-y':
            return self.accelerationY
        elif kwd == 'acceleration-z':
            return self.accelerationZ
        elif kwd.find('acceleration') > 0:
            dimension = ""
            for d in ["x", "y", "z"]:
                if d in kwd:
                    dimension += d
            return self.acceleration(dimension)
        elif kwd == 'frequency':
            return self.frequency
        elif kwd == 'reliability':
            return self.reliability
        elif kwd == 'rssi':
            return self.rssi
        else:
            return None

    # Found that initial sample often can have bogus altitude
    def accept(self):
        if self.sequenceId == 0 and self.altitude > 1000.0:
            return False
        return True

    def show(self, file, basic = False):
        a = self.acceleration()
        if basic:
            args = (self.timeStamp, self.altitude, a)
            file.write("T = %.3f.  Altitude = %.2f.  Acceleration = %.2fg\n" % args) 
        else:
            args = (self.sequenceId, self.timeStamp, self.altitude, a, self.accelerationX, self.accelerationY, self.accelerationZ, self.frequency, self.reliability, self.rssi)
            file.write("%d.  T = %.3f.  Alt = %.2f.  G's = %.2f (%.2f, %.2f, %.2f). SPS = %.2f.  Rcvd = %.1f%%.  RSSI = %d\n" % args)

    def csvHeader(self, logName, basic = False):
        if basic:
            fields = ["time", "altitude", "acceleration"]
        else:
            fields = ["sid", "time", "altitude", "acceleration", "acceleration-X", "acceleration-Y", "acceleration-Z", "SPS", "Reliability", "RSSI"]
        addLog(logName, fields, True)

    def csvLine(self, logName, basic = False):
        if basic:
            fields = ["%.3f" % self.timeStamp, "%.2f" % self.altitude, "%.2f" % self.acceleration()]
        else:
            fields = ["%d" % self.sequenceId,
                      "%.3f" % self.timeStamp,
                      "%.2f" % self.altitude,
                      "%.2f" % self.acceleration(), 
                      "%.2f" % self.accelerationX,
                      "%.2f" % self.accelerationY,
                      "%.2f" % self.accelerationZ, 
                      "%.2f" % self.frequency,
                      "%.1f" % self.reliability,
                      "%d"   % self.rssi]
        addLog(logName, fields, False)

def minMax(x, xmin, xmax):
    xmin = x if xmin is None else min(x, xmin) 
    xmax = x if xmax is None else max(x, xmax)     
    return (xmin, xmax)

class Formatter:

    sampler = None
    # How many sample tuples should be kept
    sampleKeep = 100
    # Timings of last sampleKeep receptions.  Each entry is a tuple (secs, receivedCount)
    sampleHistory = []
    # Allow recallibration of altimeter
    baseAltitude = None
    minAltitude = None
    maxAltitude = None
    minAcceleration = None
    maxAcceleration = None

    def __init__(self, sampler):
        self.sampler = sampler
        
    def formatSample(self, sampleTuple):
        (secs, sample, rssi) = sampleTuple
        fields = sample.split()
        if len(fields) < 5:
            self.sampler.report(3, "Not enough fields in sample '%s'" % sample)
            return None
        try:
            sid = int(fields[0])
        except:
            self.sampler.report(3, "Couldn't parse sample Id in '%s' (length=%d)" % (fields[0], len(fields[0])))
            return None
        try:
            ax = float(fields[1])
        except:
            self.sampler.report(3, "Couldn't parse X acceleration in '%s' (length=%d)" % (fields[1], len(fields[1])))
            return None
        try:
            ay = float(fields[2])
        except:
            self.sampler.report(3, "Couldn't parse Y acceleration in '%s' (length=%d)" % (fields[2], len(fields[2])))
            return None
        try:
            az = float(fields[3])
        except:
            self.sampler.report(3, "Couldn't parse Z acceleration in '%s' (length=%d)" % (fields[3], len(fields[3])))
            return None
        try:
            alt = float(fields[4])
        except:
            self.sampler.report(3, "Couldn't parse altitude in '%s' (length=%d)" % (fields[4], len(fields[4])))
            return None
        if self.baseAltitude is None:
            self.baseAltitude = alt
        ncount = self.sampler.receptionCount
        self.sampleHistory.append((secs, ncount))
        if len(self.sampleHistory) > self.sampleKeep:
            self.sampleHistory = self.sampleHistory[-self.sampleKeep:]
        osecs, ocount = self.sampleHistory[0]
        freq = 0.0 if ocount == ncount else float(ncount-ocount)/(secs-osecs)
        alt = alt-self.baseAltitude
        ax /= gravity
        ay /= gravity
        az /= gravity
        rate = self.sampler.receptionRate * 100
        rec = SampleRecord(time = secs, sid = sid, alt = alt, ax = ax, ay = ay, az = az, freq = freq, rate = rate, rssi = rssi)
        if not rec.accept():
            return None
        self.minAltitude, self.maxAltitude = minMax(alt, self.minAltitude, self.maxAltitude)
        self.minAcceleration, self.maxAcceleration = minMax(rec.acceleration(), self.minAcceleration, self.maxAcceleration)
        return rec

    
def run(name, args):
    port = None
    baud = 115200
    retries = 10
    verbosity = 1
    senderId = None
    slow = False
    basic = False
    logName = None
    bufSize = 3

    optList, args = getopt.getopt(args, "hBSLv:p:b:t:s:k:")
    for (opt, val) in optList:
        if opt == '-h':
            usage(name)
            return
        elif opt == '-v':
            verbosity = int(val)
        elif opt == '-p':
            try:
                pnum = int(val)
                port = devPrefix + str(pnum)
            except:
                port = val
        elif opt == '-b':
            baud = int(val)
        elif opt == '-t':
            retries = int(val)
        elif opt == '-s':
            senderId = val
        elif opt == '-B':
            basic = True
        elif opt == '-k':
            bufSize = int(val)
        elif opt == '-S':
            slow = True
        elif opt == '-L':
            logName = logFileName()
            print("Writing to log file %s" % logName)

    if port is None:
        plist = findPorts()
        if len(plist) == 0:
            print("Can't find any devices starting with names '%s'" % devPrefix)
            return
        elif len(plist) == 1:
            port = plist[0]
        elif len(plist) == 2:
            print("Ambiguous port.  Candidates are:")
            for p in plist:
                print("  %s" % p)
            return


    sampler = Sampler(port, baud, senderId, verbosity, retries) if bufSize == 0 else BufferedSampler(port, baud, senderId, verbosity, retries, bufSize)
    formatter = Formatter(sampler)
    lastTime = -1.0
    first = True
    while True:
        tup = sampler.getNextSampleTuple()
        if tup is None:
            print("Exiting")
            return
        r = formatter.formatSample(tup)
        if r is None:
            continue
        t = r.timeStamp
        if not slow or t > lastTime + 1.0:
            lastTime = math.floor(t)
            r.show(sys.stdout, basic = basic)
        if logName is not None:
            if first:
                r.csvHeader(logName, basic)
                first = False
            r.csvLine(logName, basic)
    
if __name__ == "__main__":
    run(sys.argv[0], sys.argv[1:])
    sys.exit(0)
    
