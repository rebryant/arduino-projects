#!/usr/bin/python3
# Read data generated by flight computer from serial port

# Each sample contains:
# Sequence Id
# X, Y, Z accelarations in m/s^2
# Nominal altitude in m
# 4-byte checksum

import serial
import sys
import glob
import select
import getopt
import time
import datetime
import math


def usage(name):
    print("Usage: %s [-h] [-B] [-L] [-v VERB] [-p PORT] [-b BAUD] [-t TRIES] [-s SENDER]" % name)
    print(" -h       Print this message")
    print(" -L       Save samples to CSV log file")
    print(" -B       Show only basic data")
    print(" -S       Slow to ~ 1 sample per second")
    print(" -v VERB  Verbosity level")
    
def trim(s):
    while len(s) > 0 and s[-1] in "\r\n":
        s = s[:-1]
    return s

devPrefix = "/dev/cu.usbmodem"
readTimeout = 15

gravity = 9.80665
baseAltitude = 0.0

def findPorts():
    return glob.glob(devPrefix + "*")

def readline(ser):
    failures = 0
    line = None
    while line is None and failures < 10:
        try:
            line = trim(ser.readline().decode())
        except:
            failures += 1
    return line
    
def logFileName():
    n = datetime.datetime.now()
    s = n.isoformat(sep='d', timespec='minutes')
    clist = [c for c in s]
    fclist = ["h" if c == ":" else c for c in clist]
    return "log-" + "".join(fclist) + "m.csv"

def addLog(logName, fields, first = False):
    try:
        lfile = open(logName, "w" if first else "a")
    except:
        print("Failed to add entry to log file %s" % logName)
    lfile.write(",".join(fields) + "\n")
    lfile.close()
    
    

class Sampler:
    port = None
    baud = None
    senderId = None
    retries = 10
    verbosity = 1

    reader = None
    # Samples indexed by sequence number
    # Each is a triple:
    #   Time (floating point #secconds since start)
    #   RSSI
    #   Sample payload.  Kept as string
    sampleBuffer = {}
    lastSampleId = -1
    lastSampleTime = -2.0
    rpt = 1
    startTime = 0.0

    receptionRate = 1.0
    receptionCount = 0
    done = False
    
    
    def __init__(self, port, baud, senderId, verbosity, retries):
        self.port = port
        self.baud = baud
        self.verbosity = verbosity
        self.retries = retries
        self.senderId = senderId
        self.reader = None
        self.sampleBuffer = {}
        self.lastSampleId = -1
        self.lastSampleTime = -2.0
        self.done = False
        self.receptionRate = 1.0
        self.receptionCount = 0
        self.startTime = datetime.datetime.now()
    
    def report(self, level, msg):
        if self.verbosity >= level:
            print(msg)

    def timeStamp(self):
        dt = datetime.datetime.now() - self.startTime
        secs = dt.seconds + 1e-6 * dt.microseconds
        return secs

    def error(self, fatal,  msg):
        if fatal and self.verbosity >= 1:
            print("ERROR: " + msg)
        elif self.verbosity >= 2:
            print("WARNING: " + msg)
        if fatal:
            self.done = True
        

    def connect(self):
        failures = 0
        self.reader = None
        while not self.done and self.reader is None and failures <= self.retries:
            try:
                self.reader = serial.Serial(self.port, self.baud, timeout = readTimeout)
                self.report(3, "Created serial reader port=%s, baud=%d, timeout=%d" % (self.port, self.baud, readTimeout))
            except:
                self.reader = None
                self.report(3, "Couldn't open serial port %s.  %d accumulated failures" % (self.port, failures))
                failures += 1
                time.sleep(1)
                continue
            self.report(2, "Connected to serial port %s at baud rate %d" % (self.port, self.baud)) 
            # New connection
            self.lastSampleId = -1
            self.lastSampleTime = -2.0
            self.receptionRate = 1.0
            self.sampleBuffer = {}
            return
        self.done = True
    
    def checkDone(self):
        avail =  select.select([sys.stdin], [], [], 0)
        if sys.stdin in avail[0]:
            char = sys.stdin.read(1)
            print("Read '%s' from stdin" % char)
            if len(char) > 0 and char[0] == 'q':
                self.done = True
        

    # Use decaying value
    def updateRate(self, received):
        if received:
            self.receptionRate = 0.99 * self.receptionRate + 0.01
        else:
            self.receptionRate = 0.99 * self.receptionRate

    def getLine(self):
        failures = 0
        if self.reader is None:
            self.connect()
        if self.reader is None:
            return None
        while (not self.done and failures < self.retries):
            try:
                line = readline(self.reader)
            except Exception as ex:
                self.error(False, "Readline failed: %s" % str(ex))
                line = None
            self.report(4, "Read line '%s'" % trim(str(line)))
            if line is None:
                self.report(3, "Read Failed.  %d accumulated failures" % (failures))
                failures += 1
                time.sleep(1)
                self.connect()
            else:
                return trim(line)
        self.done = True
        return None

    def getNextSampleTuple(self):
#        self.checkDone()
        while len(self.sampleBuffer) == 0 and not self.done:
            line = self.getLine()
            if line is not None:
                self.parseLine(line)
        catchingUp = self.lastSampleId < 0
        if len(self.sampleBuffer) > 0:
            # Sometimes start at middle of stream
            self.lastSampleId += 1
            while self.lastSampleId not in self.sampleBuffer:
                self.lastSampleId += 1
                if not catchingUp:
                    # Missed sample
                    self.updateRate(False)
            sampleTuple = self.sampleBuffer[self.lastSampleId]
            self.updateRate(True)
            self.receptionCount += 1
            catchingUp = False
            del self.sampleBuffer[self.lastSampleId]
            return sampleTuple
        return None
                

    def parseLine(self, line):
        fields = line.split()
        if len(fields) < 3:
            self.error(False, "Line '%s'.  Not enough fields" % line)
            return
        if self.senderId is not None and fields[2] != self.senderId:
            self.error(False, "Line '%s'.  Incorrect sender Id" % line)
            return
        try:
            rpt = int(fields[1])
        except:
            self.error(False, "Line '%s'.  Couldn't parse rpt field" % line)
            return
        if rpt == 0:
            self.report(2, "Hit end of transmission")
            return
        if rpt <= 0:
            self.error(False, "Line '%s'.  Invalid rpt field" % line)
            return
        if rpt == 0:
            self.done = True
            return
        try:
            rssi = int(fields[0])
        except:
            self.error(False, "Line '%s'.  Couldn't parse RSSI field" % line)
            return
        if (len(fields) - 3) % rpt != 0:
            self.error(False, "Line '%s'.  Can't have %d fields with rpt = %d" % (line, len(fields), rpt))
            return
        fps = (len(fields)-3)//rpt
        # See what samples are included
        sidList = []
        offset = 3
        while offset < len(fields):
            try:
                sid = int(fields[offset])
            except:
                pass
            sidList.append(sid)
            offset += fps

        # See if sequence ID has shifted lower
        if max(sidList) < self.lastSampleId:
            self.report(3, "Starting new stream")
            # Resetting stream
            self.lastSampleId = -1
            self.lastSampleTime = -2.0
            self.receptionRate = 1.0
            self.sampleBuffer = {}
        
        # Find out which Ids will be added
        sidList = sorted([sid for sid in sidList if sid > self.lastSampleId and sid not in self.sampleBuffer])
        # Determine interpolating values for times
        t = self.timeStamp()
        if (t-self.lastSampleTime) > 1.0:
            self.lastSampleTime = t - 1.0
        dt = t-self.lastSampleTime
        incrT = dt/(len(sidList)+1)
        sidTimes = {}
        self.lastSampleTime += incrT
        for sid in sidList:
            sidTimes[sid] = self.lastSampleTime
            self.lastSampleTime += incrT
        offset = 3
        while offset < len(fields):
            try:
                sid = int(fields[offset])
            except:
                pass
            if sid > self.lastSampleId and sid not in self.sampleBuffer:
                sample = " ".join(fields[offset:offset+fps])
                t = sidTimes[sid]
                self.sampleBuffer[sid] = (t, sample, rssi)
                self.report(3, "Creating sample with time %.3f, sid %d" % (t, sid))
            else:
                self.report(3, "Skipping sample with sid %d" % sid)
            offset += fps
        
# How many sample tuples should be kept
sampleKeep = 100
# Timings of last sampleWindow receptions.  Each entry is a tuple (secs, receivedCount)
sampleHistory = []

class SampleRecord:
    timeStamp = 0.0
    sequenceId = 0
    altitude = 0.0
    accelerationX = 0.0
    accelerationY = 0.0
    accelerationZ = 0.0
    frequency = 0.0
    reliability = 0.0
    rssi = 0

    def __init__(self, time = None, sid = None, alt = None, ax = None, ay = None , az = None, freq = None, rate=None, rssi=None):
        self.timeStamp = time
        self.sequenceId = sid
        self.altitude = alt
        self.accelerationX = ax
        self.accelerationY = ay    
        self.accelerationZ = az
        self.frequency = freq
        self.reliability = rate
        self.rssi = rssi
    
    def acceleration(self):
        return math.sqrt(self.accelerationX * self.accelerationX + self.accelerationY * self.accelerationY + self.accelerationZ * self.accelerationZ)

    def getField(self, kwd):
        if kwd == 'Sequence':
            return self.sequenceId
        elif kwd == 'Altitude':
            return self.altitude
        elif kwd == 'Acceleration':
            return self.acceleration()
        elif kwd == 'X-Acceleration':
            return self.accelerationX
        elif kwd == 'Y-Acceleration':
            return self.accelerationY
        elif kwd == 'Z-Acceleration':
            return self.accelerationZ
        elif kwd == 'Frequency':
            return self.frequency
        elif kwd == 'Reliability':
            return self.reliability
        elif kwd == 'RSSI':
            return self.rssi
        else:
            return None

    def show(self, file, basic = False):
        a = self.acceleration()
        if basic:
            args = (self.timeStamp, self.altitude, a)
            file.write("T = %.3f.  Altitude = %.2f.  Acceleration = %.2fg\n" % args) 
        else:
            args = (self.sequenceId, self.timeStamp, self.altitude, a, self.accelerationX, self.accelerationY, self.accelerationZ, self.frequency, self.reliability, self.rssi)
            file.write("%d.  T = %.3f.  Alt = %.2f.  G's = %.2f (%.2f, %.2f, %.2f). SPS = %.2f.  Rcvd = %.1f%%.  RSSI = %d\n" % args)

    def csvHeader(self, logName, basic = False):
        if basic:
            fields = ["time", "altitude", "acceleration"]
        else:
            fields = ["sid", "time", "altitude", "acceleration", "acceleration-X", "acceleration-Y", "acceleration-Z", "SPS", "Reliability", "RSSI"]
        addLog(logName, fields, True)

    def csvLine(self, logName, basic = False):
        if basic:
            fields = ["%.3f" % self.timeStamp, "%.2f" % self.altitude, "%.2f" % self.acceleration()]
        else:
            fields = ["%d" % self.sequenceId,
                      "%.3f" % self.timeStamp,
                      "%.2f" % self.altitude,
                      "%.2f" % self.acceleration(), 
                      "%.2f" % self.accelerationX,
                      "%.2f" % self.accelerationY,
                      "%.2f" % self.accelerationZ, 
                      "%.2f" % self.frequency,
                      "%.1f" % self.reliability,
                      "%d"   % self.rssi]
        addLog(logName, fields, False)

def formatSample(sampleTuple, sampler):
    global sampleHistory
    global baseAltitude
    (secs, sample, rssi) = sampleTuple
    fields = sample.split()
    if len(fields) < 5:
        sampler.report(3, "Not enough fields in sample '%s'" % sample)
        return None
    try:
        sid = int(fields[0])
    except:
        sampler.report(3, "Couldn't parse sample Id in '%s' (length=%d)" % (fields[0], len(fields[0])))
        return None
    try:
        ax = float(fields[1])
    except:
        sampler.report(3, "Couldn't parse X acceleration in '%s' (length=%d)" % (fields[1], len(fields[1])))
        return None
    try:
        ay = float(fields[2])
    except:
        sampler.report(3, "Couldn't parse Y acceleration in '%s' (length=%d)" % (fields[2], len(fields[2])))
        return None
    try:
        az = float(fields[3])
    except:
        sampler.report(3, "Couldn't parse Z acceleration in '%s' (length=%d)" % (fields[3], len(fields[3])))
        return None
    try:
        alt = float(fields[4])
    except:
        sampler.report(3, "Couldn't parse altitude in '%s' (length=%d)" % (fields[4], len(fields[4])))
        return None
    if baseAltitude == 0.0:
        baseAltitude = alt
    ncount = sampler.receptionCount
    sampleHistory.append((secs, ncount))
    if len(sampleHistory) > sampleKeep:
        sampleHistory = sampleHistory[-sampleKeep:]
    osecs, ocount = sampleHistory[0]
    freq = 0.0 if ocount == ncount else float(ncount-ocount)/(secs-osecs)
    alt = alt-baseAltitude
    ax /= gravity
    ay /= gravity
    az /= gravity
    a = math.sqrt(ax*ax + ay*ay + az*az)

    rate = sampler.receptionRate * 100
    rec = SampleRecord(time = secs, sid = sid, alt = alt, ax = ax, ay = ay, az = az, freq = freq, rate = rate, rssi = rssi)
    return rec



    
def run(name, args):
    port = None
    baud = 115200
    retries = 10
    verbosity = 1
    senderId = None
    slow = False
    basic = False
    logName = None

    optList, args = getopt.getopt(args, "hBSLv:p:b:t:s:")
    for (opt, val) in optList:
        if opt == '-h':
            usage(name)
            return
        elif opt == '-v':
            verbosity = int(val)
        elif opt == '-p':
            try:
                pnum = int(val)
                port = devPrefix + str(pnum)
            except:
                port = val
        elif opt == '-b':
            baud = int(val)
        elif opt == '-t':
            retries = int(val)
        elif opt == '-s':
            senderId = val
        elif opt == '-B':
            basic = True
        elif opt == '-S':
            slow = True
        elif opt == '-L':
            logName = logFileName()
            print("Writing to log file %s" % logName)

    if port is None:
        plist = findPorts()
        if len(plist) == 0:
            print("Can't find any devices starting with names '%s'" % devPrefix)
            return
        elif len(plist) == 1:
            port = plist[0]
        elif len(plist) == 2:
            print("Ambiguous port.  Candidates are:")
            for p in plist:
                print("  %s" % p)
            return


    sampler = Sampler(port, baud, senderId, verbosity, retries)
    lastTime = -1.0
    first = True
    while True:
        tup = sampler.getNextSampleTuple()
        if tup is None:
            print("Exiting")
            return
        r = formatSample(tup, sampler)
        if r is None:
            continue
        t = r.timeStamp
        if not slow or t > lastTime + 1.0:
            lastTime = math.floor(t)
            r.show(sys.stdout, basic = basic)
        if logName is not None:
            if first:
                r.csvHeader(logName, basic)
                first = False
            r.csvLine(logName, basic)
    
if __name__ == "__main__":
    run(sys.argv[0], sys.argv[1:])
    sys.exit(0)
    
